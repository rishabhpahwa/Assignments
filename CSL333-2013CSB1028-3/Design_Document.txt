#########################################
#	CSL333: Assignment 3		#
#	Name: Rishabh Pahwa		#
#	Entry No: 2013CSB1028		#
#########################################

DESIGN DOCUMENT:

	* The program starvation.c asks for input to number of type of resources and subsequently the maximum
	  number of tasks to be allocated by the system.
	  
	* It maintains two structs:
		a) For storing information of each individual resource.
			
			typedef struct res
			{
				int id;		-> for storing the ID of each resource.
				int cost;	-> How much cost it takes to execute one instance of the resource.
				int cap_ips;	-> How many Instructions per second can the resource perform.
			} resource;
	
		b) For storing the information of each individual task created by the system.
		   
		   	typedef struct task
			{
				struct task *front;	-> pointer to the task ahead of it in the queue.
				struct task *back;	-> pointer to the task behind it in the queue.
				int p;			-> Initial priority of the task (as generated by system)
				int s;			-> Number of instructions it consumes (Cost)
				int task_id;		-> For storing in what order the tasks are created.
				int resources[];	-> Array to store the resource ids the task consumes.
			} task;
			
	* As nothing concrete was mentioned in the problem as to how to fill in each of the above details of the
	  structs, most of it was done randomly. The ID's for both of the above cases was assigned in increasing order
	  (of allocation in relation to resources and creation by system in relation to tasks). The cost of each resource,
	  its capacity, priority(p) and cost(s) of the tasks and the resources a task chooses was all filled in randomly
	  using the library functions srand(seed) and rand().
	  
	* The resources were first created and then the tasks were allocated by the system on the created set of resources.
	  
	* The tasks once created are sent to the queue which manages them as follows:
		1. The task with higher initial priority are favoured first.
		2. If the priority of more than one task is same then, it favors the task which requires less number of resources.
		3. If both the above are same, then it arranges them on First-Come-First-Serve basis.
		
		PS: The head element in the queue is manually assigned the Highest priority so that the head pointer in the 
		    Program remains unchanged. This was done to simplify the coding process. So the actual tasks begin from
		    index = 1 in the queue, instead of 0.
		    
Discussion:

	The algorithm provided by me is not starvation free as a higher priority task, however late it arrives, would always
	be preferred over a task with lower priority. Hence if a lower priority task is stuck behind a higher priority task,
	it would never be executed if more higher priority tasks are added to the queue subsequently.
	
	Comparison:
	
		The algorithm implemented takes into account the priorities and also reduces the average wait time for a process
		with same priority where as the round robin approach just provides time slices to a program in intervals.
		Round robin algorithm requires too many context switches and considering there is only a single type of resource
		available in the system, the provided algorithm works better than round robin for the given scenario.
		The Shortest remaining time first and FCFS algorithms are already implemented hybridly in the algorithm provided
		and the hybrid would work better than any of the individual ones as priority too is taken into consideration in
		the algorithm designed.
		
-Rishabh Pahwa
Entry No: 2013CSB1028
Institute:  IIT-Ropar.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
